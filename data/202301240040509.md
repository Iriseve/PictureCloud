---
title: "可变参数"
date: 2023-01-23T23:12:56+08:00
lastmod: 2023-01-23T23:12:56+08:00
author: ["yiling"]

categories:
- java

tags:
- java

keywords:
- java
- 可变参数

description: "可变参数" # 文章描述，与搜索优化相关
summary: "可变参数的简单使用" # 文章简单描述，会展示在主页
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论
showToc: true # 显示目录
TocOpen: true # 自动展开目录
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: true # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true
cover:
    image: ""  #图片路径：posts/tech/文章1/picture.png
    caption: ""  #图片底部描述
    alt: ""
    relative: false
---

#### 定义方法

+ Java 5提供了变长参数，允许 在调用方法时传入不定长度的参数 。 

+  一个方法中**只能指定一个可变参数**，它必须是方法的**最后一个参数**。任何普通的参数必须在它之前声明。 
+ 本质上还是基于数组的实现 。方法签名是一致的。 可变参数可以兼容数组，反之则不成立 。

~~~java
//两者等价，所以无法构成方法重载。
//如果同时出现，无法编译通过。
void func(typeName... args); //参数为可变参数
void func(typeName[] args); //参数为typeName数组
~~~

+ 泛型机制不能和个数可变的形参配合使用。

#### 调用

把可变参数当作数组来看待使用，其他都一样。

#### 重载

+ 优先匹配固定参数

~~~java
public class Varargs {
    public static void test(String... args) {
        System.out.println("version 1");
    }

    public static void test(String arg1, String arg2) {
        System.out.println("version 2");
    }
    
    public static void main(String[] args) {
        test("a","b");//version 2 优先匹配固定参数的重载方法
        test();//version 1
    }
}
~~~

+ 不能匹配多个可变参数

 调用一个被重载的方法时，如果此调用既能够和两个可变长参数的重载方法匹配，则编译出错: 

~~~java
public class Varargs {
    public static void test(String... args) {
        System.out.println("version 1");
    }

    public static void test(String arg1, String... arg2) {
        System.out.println("version 3");
    }

    public static void main(String[] args) {
        test("a");
    }
}
~~~

![1674484657375](../../../../笔记/images/可变参数/1674484657375.png)

+ 注意null值和空值对不同类型的可变参数的影响

#### Object...

~~~java
public class VarArgsTest3 {
    public static void foo(Object... args) {
        System.out.println(args.length);
    }

    public static void main(String[] args) {
        foo(new String[]{"arg1", "arg2", "arg3"}); //3
        foo(100, new String[]{"arg1", "arg1"}); //2

        foo(new Integer[]{1, 2, 3}); //3 Integer[]可以转型为Object[],作为一个对象数组
        foo(100, new Integer[]{1, 2, 3}); //2
        foo(1, 2, 3); //3
        foo(new int[]{1, 2, 3}); //1 int[]无法转型为Object[]
    }

}
~~~

同理，在反射方法调用时也需要注意。

 反射是运行时获取的，在运行时看来，可变长参数和数组是一致的。

~~~java
Object invoke(Object obj, Object... args)
~~~

 args虽然是一个可变长度的参数，但是 args 的长度是**受限于该方法对象代表的真实方法的参数列表长度的**，而从运行时签名来看，可变参数 实际上只有一个形参，即 String[] varargs，因而 invoke(Object obj, Object… args) 中可变参数 args 的实参长度只能为1 。

#### 总结

在**不确定方法需要处理的对象的数量**时可以使用可变长参数，会使得方法调用更简单，无需手动创建数组 **new T[]{…}** 。

但在方法可能发生重载时，最好不要用！避免发生一些没必要的问题hhha

#### 参考

 [Java 可变参数](https://www.runoob.com/w3cnote/java-varargs-parameter.html) 